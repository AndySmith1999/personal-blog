/*
SQLyog Ultimate v10.00 Beta1
MySQL - 5.7.19 
*********************************************************************
*/
/*!40101 SET NAMES utf8 */;

create table `m_blog` (
	`id` bigint ,
	`user_id` bigint ,
	`title` varchar ,
	`description` varchar ,
	`content` text (-1),
	`created` datetime ,
	`status` tinyint 
); 
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('1','1','测试标题3333','摘要333','33333','2021-08-21 22:53:04','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('2','1','测试标题人生','摘要人生','?PNG\r\n\Z\n','2021-08-22 20:05:34','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('3','1','博客','博客摘要','博客内容','2021-08-21 22:59:07','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('4','1','算法','牛客','算法训练','2021-08-24 22:18:14',NULL);
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('5','1','音乐','人生如戏','撒旦法萨 算法暗室逢灯','2021-08-24 22:18:59',NULL);
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('6','1','游戏',' 的速度 ','第三方三大as','2021-08-24 22:19:22',NULL);
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('7','1','胡超88','超哥超哥超哥超而过','	# 牛逼66666\n\n的都是\n# 地方 ','2021-08-24 22:57:07','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('10','1','面向对象设计七大原则','面向对象设计七大原则','@[TOC](目录)\n\n\n\n## 1. 单一职责原则（Single Responsibility Principle）\n\n每一个类应该专注于做一件事情。\n\n## 2. 里氏替换原则（Liskov Substitution Principle）\n\n超类存在的地方，子类是可以替换的。\n\n## 3. 依赖倒置原则（Dependence Inversion Principle）\n\n实现尽量依赖抽象，不依赖具体实现。\n\n## 4. 接口隔离原则（Interface Segregation Principle）\n\n应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。\n\n## 5. 迪米特法则（Law Of Demeter）\n\n又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。\n\n## 6. 开闭原则（Open Close Principle）\n\n面向扩展开放，面向修改关闭。\n\n## 7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）\n\n尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。\n\n# 细则\n## 单一职责原则（Single Responsibility Principle）\n\n**定义**：**一个类，只有一个引起它变化的原因。即：应该只有一个职责。**\n\n每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。 \n\n**问题由来**：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 \n\n**解决方法**：分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。\n\n\n**因为：**\n\n可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。\n\n**所以：**\n\n从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。\n\n## 里氏替换原则（Liskov Substitution Principle）\n**定义：子类型必须能够替换掉它们的父类型。注意这里的能够两字。有人也戏称老鼠的儿子会打洞原则。**\n\n**问题由来**：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。 \n\n**解决方法**：类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法 \n\n**小结**：所有引用父类的地方必须能透明地使用其子类的对象。子类可以扩展父类的功能，但不能改变父类原有的功能，即：子类可以实现父类的抽象方法，子类也中可以增加自己特有的方法，但不能覆盖父类的非抽象方法。当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。\n\n**因为：**\n\n里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。\n\n**所以：**\n\n使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。\n\n从大局看Java的多态就属于这个原则。\n\n## 依赖倒置原则（Dependence Inversion Principle）\n**定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。中心思想是面向接口编程** \n\n**问题由来**：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 \n\n**解决方法**：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 \n\n在实际编程中，我们一般需要做到如下3点：\n\n1）. 低层模块尽量都要有抽象类或接口，或者两者都有。\n\n2）. 变量的声明类型尽量是抽象类或接口。\n\n3）. 使用继承时遵循里氏替换原则。 \n\n采用依赖倒置原则尤其给多人合作开发带来了极大的便利，参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。 \n\n**小结**：依赖倒置原则就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。 \n\n\n**因为：**\n\n具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。\n\n**所以：**\n\n采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。\n\n从大局看Java的多态就属于这个原则。\n\n## 接口隔离原则（Interface Segregation Principle）\n**定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。** \n\n**问题由来**：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法 \n\n**解决方法**：\n1、 使用委托分离接口。\n2、 使用多重继承分离接口。\n3.将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。 \n\n**举例说明：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d252f588896341d89518034d124b92b2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n下面我们来看张图，一切就一目了然了。\n这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法\n\n修改后：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/ac53c8df9fca4919bde6f183099a2678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口\n\n**小结**：我们在代码编写过程中，运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。设计接口的时候，只有多花些时间去思考和筹划，就能准确地实践这一原则。 \n\n\n**因为：**\n\n提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。\n\n**所以：**\n\n建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\n\n从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。\n\n## 迪米特法则（Law Of Demeter）\n**定义：迪米特法则又叫最少知道原则，即：一个对象应该对其他对象保持最少的了解。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。简单定义为只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。**\n\n**问题由来**：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。\n\n最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。 \n\n**解决方法**：尽量降低类与类之间的耦合。 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。 \n\n迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。故过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 \n\n\n**因为：**\n\n类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。\n\n**所以：**\n\n一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。\n\n从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。\n\n## 开闭原则（Open Close Principle）\n**定义：软件实体应当对扩展开放，对修改关闭。这句话说得有点专业，更通俗一点讲，也就是：软件系统中包含的各种组件，例如模块（Modules）、类（Classes）以及功能（Functions）等等，应该在不修改现有代码的基础上，去扩展新功能。开闭原则中原有“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于代码的修改是封闭的，即不应该修改原有的代码。**\n\n**问题由来**：凡事的产生都有缘由。我们来看看，开闭原则的产生缘由。在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。这就对我们的整个系统的影响特别大，这也充分展现出了系统的耦合性如果太高，会大大的增加后期的扩展，维护。为了解决这个问题，故人们总结出了开闭原则。解决开闭原则的根本其实还是在解耦合。所以，我们面向对象的开发，我们最根本的任务就是解耦合。 \n\n**解决方法**：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 \n\n**小结**：开闭原则具有理想主义的色彩，说的很抽象，它是面向对象设计的终极目标。其他几条原则，则可以看做是开闭原则的实现。我们要用抽象构建框架，用实现扩展细节。\n\n\n**因为：**\n\n开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。\n\n**所以：**\n\n可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。 \n封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。\n\n## 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）\n**定义：也有人叫做合成复用原则，及尽量使用合成/聚合，尽量不要使用类继承。换句话说，就是能用合成/聚合的地方，绝不用继承。** \n\n**为什么要尽量使用合成/聚合而不使用类继承？**\n\n> 1. 对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现\n> \n> 2. 子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化\n> \n> 3. 当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换，这种依赖关系限制了灵活性，并最终限制了复用性。\n\n**总结**：这些原则在设计模式中体现的淋淋尽致，设计模式就是实现了这些原则，从而达到了代码复用、增强了系统的扩展性。所以设计模式被很多人奉为经典。我们可以通过好好的研究设计模式，来慢慢的体会这些设计原则。\n\n**因为：**\n\n其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。\n\n如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。\n\n**所以：**\n\n组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。\n\n# 更多相关文章点这里哦\n\n[面向对象基础全总结\n](https://blog.csdn.net/qq_45696377/article/details/112439241)\n\n[【Java全栈】Java全套学习路线及项目资料总结【JavaSE+Web基础+MySQL+JavaEE】](https://blog.csdn.net/qq_45696377/article/details/110575362)\n\n','2021-08-25 10:19:08','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('11','1','Mybatis作用域（Scope）和生命周期','关于Mybatis作用域（Scope）和生命周期的详细分析文章','@[TOC](目录)\n\n\n**理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题。**\n画一个流程图，分析一下Mybatis的执行过程！\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b13890d3c42e4e97a2aee7bfb4e227b3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n\n**提示：对象生命周期和依赖注入框架**\n\n依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。\n\n# SqlSessionFactoryBuilder\n\n> 这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此\n> SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用\n> SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory\n> 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。\n\n - 一旦创建了SqlSessionFactory，就不再需要它了\n - 局部变量\n\n# SqlSessionFactory\n\n> SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用\n> SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory\n> 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。\n> 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。\n\n - 说白了就可以想象为：数据库连接池\n - SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建一个实例。\n - 因此SqlSessionFactory的最佳作用域是应用作用域（ApplicationContext）。\n - 最简单的就是使用单例模式或静态单例模式。\n\n# SqlSession\n\n> 每个线程都应该有它自己的 SqlSession 实例。SqlSession\n> 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession\n> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如\n> Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP\n> 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。\n> 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保\n> SqlSession 关闭的标准模式：\n\n```java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  // 你的应用逻辑代码\n}\n```\n\n在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。\n\n - 连接到连接池的一个请求\n - SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n - 用完之后需要赶紧关闭，否则资源被占用！\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/99e8c5677529467282bad509fa7e4f6e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n这里的每一个Mapper就代表一个具体的业务\n\n\n# 映射器实例\n\n> 映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession\n> 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession\n> 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。\n> 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像\n> SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：\n\n```java\ntry (SqlSession session = sqlSessionFactory.openSession()) {\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\n  // 你的应用逻辑代码\n}\n```\n\n\n# 作用域理解\n\n - SqlSessionFactoryBuilder 的作用在于创建\n   SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建\n   SqlSessionFactory 的方法中，而不要让其长期存在。因此 **SqlSessionFactoryBuilder\n   实例的最佳作用域是方法作用域**（也就是局部方法变量）。\n   \n - SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis\n   的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis\n   的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为\n   SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。\n - 因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。**所以说\n   SqlSessionFactory 的最佳作用域是应用作用域。**\n   \n - 如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection\n   对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback\n   等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给\n   SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try...catch...finally...\n   语句来保证其正确关闭。\n   \n - **所以 SqlSession 的最佳的作用域是请求或方法作用域。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/16472120b1ef45d8a3324c166880b691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n# 更多相关文章点这里哦\n\n[【Java全栈】Java全套学习路线及项目资料总结【JavaSE+Web基础+MySQL+JavaEE】](https://blog.csdn.net/qq_45696377/article/details/110575362)','2021-08-25 10:21:17','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('12','1','分布式系统唯一ID生成方案汇总','分布式系统唯一ID生成方案汇总','@[TOC](目录)\n> 系统唯一ID是我们在设计一个系统的时候常常会遇见的问题，也常常为这个问题而纠结。生成ID的方法有很多，适应不同的场景、需求以及性能要求。所以有些比较复杂的系统会有多个ID生成的策略。下面就介绍一些常见的ID生成策略。\n\n# 1. 数据库自增长序列或字段\n\n最常见的方式。利用数据库，全数据库唯一。\n\n**优点：**\n\n1）简单，代码方便，性能可以接受。\n\n2）数字ID天然排序，对分页或者需要排序的结果很有帮助。\n\n \n\n**缺点：**\n\n1）不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。\n\n2）在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。\n\n3）在性能达不到要求的情况下，比较难于扩展。（不适用于海量高并发）\n\n4）如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。\n\n5）分表分库的时候会有麻烦。\n\n6）并非一定连续，类似MySQL，当生成新ID的事务回滚，那么后续的事务也不会再用这个ID了。这个在性能和连续性的折中。如果为了保证连续，必须要在事务结束后才能生成ID，那性能就会出现问题。\n\n7）在分布式数据库中，如果采用了自增主键的话，有可能会带来尾部热点。分布式数据库常常使用range的分区方式，在大量新增记录的时候，IO会集中在一个分区上，造成热点数据。\n\n**优化方案：**\n\n1）针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。\n\n# 2. UUID\n\n常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。UUID是由32个的16进制数字组成，所以每个UUID的长度是128位（16^32 = 2^128）。UUID作为一种广泛使用标准，有多个实现版本，影响它的因素包括时间、网卡MAC地址、自定义Namesapce等等。\n\n**优点：**\n\n1）简单，代码方便。\n\n2）生成ID性能非常好，基本不会有性能问题。\n\n3）全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。\n\n \n\n**缺点：**\n\n1）没有排序，无法保证趋势递增。\n\n2）UUID往往是使用字符串存储，查询的效率比较低。\n\n3）存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。\n\n4）传输数据量大\n\n5）不可读。\n\n\n\n# 3. UUID的变种\n\n1）为了解决UUID不可读，可以使用UUID to Int64的方法。及\n\n\n```java\n/// <summary>\n/// 根据GUID获取唯一数字序列\n/// </summary>\npublic static long GuidToInt64()\n{\n    byte[] bytes = Guid.NewGuid().ToByteArray();\n    return BitConverter.ToInt64(bytes, 0);\n}\n```\n\n  \n2）为了解决UUID无序的问题，NHibernate在其主键生成方式中提供了Comb算法（combined guid/timestamp）。保留GUID的10个字节，用另6个字节表示GUID生成的时间（DateTime）。\n\n\n```java\n/// <summary> \n/// Generate a new <see cref=\"Guid\"/> using the comb algorithm. \n/// </summary> \nprivate Guid GenerateComb()\n{\n    byte[] guidArray = Guid.NewGuid().ToByteArray();\n \n    DateTime baseDate = new DateTime(1900, 1, 1);\n    DateTime now = DateTime.Now;\n \n    // Get the days and milliseconds which will be used to build    \n    //the byte string    \n    TimeSpan days = new TimeSpan(now.Ticks - baseDate.Ticks);\n    TimeSpan msecs = now.TimeOfDay;\n \n    // Convert to a byte array        \n    // Note that SQL Server is accurate to 1/300th of a    \n    // millisecond so we divide by 3.333333    \n    byte[] daysArray = BitConverter.GetBytes(days.Days);\n    byte[] msecsArray = BitConverter.GetBytes((long)\n      (msecs.TotalMilliseconds / 3.333333));\n \n    // Reverse the bytes to match SQL Servers ordering    \n    Array.Reverse(daysArray);\n    Array.Reverse(msecsArray);\n \n    // Copy the bytes into the guid    \n    Array.Copy(daysArray, daysArray.Length - 2, guidArray,\n      guidArray.Length - 6, 2);\n    Array.Copy(msecsArray, msecsArray.Length - 4, guidArray,\n      guidArray.Length - 4, 4);\n \n    return new Guid(guidArray);\n}\n```\n\n \n用上面的算法测试一下，得到如下的结果：作为比较，前面3个是使用COMB算法得出的结果，最后12个字符串是时间序（统一毫秒生成的3个UUID），过段时间如果再次生成，则12个字符串会比图示的要大。后面3个是直接生成的GUID。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0f01fff6937f4e488b8d46a6253a3e3c.png)\n\n如果想把时间序放在前面，可以生成后改变12个字符串的位置，也可以修改算法类的最后两个Array.Copy。\n\n# 4. Redis生成ID\n\n当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。\n\n可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：\n\nA：1,6,11,16,21\n\nB：2,7,12,17,22\n\nC：3,8,13,18,23\n\nD：4,9,14,19,24\n\nE：5,10,15,20,25\n\n这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。但是步长和初始值一定需要事先需要了。使用Redis集群也可以方式单点故障的问题。\n\n另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。\n\n \n\n**优点：**\n\n1）不依赖于数据库，灵活方便，且性能优于数据库。\n\n2）数字ID天然排序，对分页或者需要排序的结果很有帮助。\n\n**缺点：**\n\n1）如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。\n\n2）需要编码和配置的工作量比较大。\n\n# 5. Twitter的snowflake(雪花)算法\n\nsnowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看https://github.com/twitter/snowflake。雪花算法支持的TPS可以达到419万左右（2^22*1000）。\n\n雪花算法在工程实现上有单机版本和分布式版本。单机版本如下，分布式版本可以参看\n**美团leaf算法：**\n**https://github.com/Meituan-Dianping/Leaf**\n\n```csharp\n/// <summary>\n    /// From: https://github.com/twitter/snowflake\n    /// An object that generates IDs.\n    /// This is broken into a separate class in case\n    /// we ever want to support multiple worker threads\n    /// per process\n    /// </summary>\n    public class IdWorker\n    {\n        private long workerId;\n        private long datacenterId;\n        private long sequence = 0L;\n\n        private static long twepoch = 1288834974657L;\n\n        private static long workerIdBits = 5L;\n        private static long datacenterIdBits = 5L;\n        private static long maxWorkerId = -1L ^ (-1L << (int)workerIdBits);\n        private static long maxDatacenterId = -1L ^ (-1L << (int)datacenterIdBits);\n        private static long sequenceBits = 12L;\n\n        private long workerIdShift = sequenceBits;\n        private long datacenterIdShift = sequenceBits + workerIdBits;\n        private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n        private long sequenceMask = -1L ^ (-1L << (int)sequenceBits);\n\n        private long lastTimestamp = -1L;\n        private static object syncRoot = new object();\n\n        public IdWorker(long workerId, long datacenterId)\n        {\n\n            // sanity check for workerId\n            if (workerId > maxWorkerId || workerId < 0)\n            {\n                throw new ArgumentException(string.Format(\"worker Id can\'t be greater than %d or less than 0\", maxWorkerId));\n            }\n            if (datacenterId > maxDatacenterId || datacenterId < 0)\n            {\n                throw new ArgumentException(string.Format(\"datacenter Id can\'t be greater than %d or less than 0\", maxDatacenterId));\n            }\n            this.workerId = workerId;\n            this.datacenterId = datacenterId;\n        }\n\n        public long nextId()\n        {\n            lock (syncRoot)\n            {\n                long timestamp = timeGen();\n\n                if (timestamp < lastTimestamp)\n                {\n                    throw new ApplicationException(string.Format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n                }\n\n                if (lastTimestamp == timestamp)\n                {\n                    sequence = (sequence + 1) & sequenceMask;\n                    if (sequence == 0)\n                    {\n                        timestamp = tilNextMillis(lastTimestamp);\n                    }\n                }\n                else\n                {\n                    sequence = 0L;\n                }\n\n                lastTimestamp = timestamp;\n\n                return ((timestamp - twepoch) << (int)timestampLeftShift) | (datacenterId << (int)datacenterIdShift) | (workerId << (int)workerIdShift) | sequence;\n            }\n        }\n\n        protected long tilNextMillis(long lastTimestamp)\n        {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp)\n            {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n\n        protected long timeGen()\n        {\n            return (long)(DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalMilliseconds;\n        }\n    }\n```\n\n测试代码如下：\n\n```csharp\nprivate static void TestIdWorker()\n        {\n            HashSet<long> set = new HashSet<long>();\n            IdWorker idWorker1 = new IdWorker(0, 0);\n            IdWorker idWorker2 = new IdWorker(1, 0);\n            Thread t1 = new Thread(() => DoTestIdWoker(idWorker1, set));\n            Thread t2 = new Thread(() => DoTestIdWoker(idWorker2, set));\n            t1.IsBackground = true;\n            t2.IsBackground = true;\n\n            t1.Start();\n            t2.Start();\n            try\n            {\n                Thread.Sleep(30000);\n                t1.Abort();\n                t2.Abort();\n            }\n            catch (Exception e)\n            {\n            }\n\n            Console.WriteLine(\"done\");\n        }\n\n        private static void DoTestIdWoker(IdWorker idWorker, HashSet<long> set)\n        {\n            while (true)\n            {\n                long id = idWorker.nextId();\n                if (!set.Add(id))\n                {\n                    Console.WriteLine(\"duplicate:\" + id);\n                }\n\n                Thread.Sleep(1);\n            }\n        }\n```\n\n\nsnowflake算法可以根据自身项目的需要进行一定的修改。比如估算未来的数据中心个数，每个数据中心的机器数以及统一毫秒可以能的并发数来调整在算法中所需要的bit数。\n\n**优点：**\n\n1）不依赖于数据库，灵活方便，且性能优于数据库。\n\n2）ID按照时间在单机上是递增的。\n\n**缺点：**\n\n1）在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，在算法上要解决时间回拨的问题。\n\n\n# 6. 利用zookeeper生成唯一ID\n\n \n\n - **zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。**\n \n \n - **很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。**\n\n \n# 7. MongoDB的ObjectId\n\nMongoDB的ObjectId和snowflake算法类似。它设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成它。MongoDB 从一开始\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2a5535b9ee3e404ea21567df845e1252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n前4 个字节是从标准纪元开始的时间戳，单位为秒。时间戳，与随后的5 个字节组合起来，提供了秒级别的唯一性。由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。 \n接下来的3 字节是所在主机的唯一标识符。通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。 \n为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的，接下来的两字节来自产生ObjectId 的进程标识符（PID）。 \n前9 字节保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId。\n\n实现的源码可以到MongoDB官方网站下载。\n\n# 8. TiDB的主键\nTiDB默认是支持自增主键的，对未声明主键的表，会提供了一个隐式主键_tidb_rowid，因为这个主键大体上是单调递增的，所以也会出现我们前面说的“尾部热点”问题。\n\nTiDB也提供了UUID函数，而且在4.0版本中还提供了另一种解决方案AutoRandom。TiDB 模仿MySQL的 AutoIncrement，提供了AutoRandom关键字用于生成一个随机ID填充指定列。\n\n# 更多相关文章点点这里\n【Java全栈】Java全栈学习路线及项目全资料总结【JavaSE+Web基础+大前端进阶+SSM+微服务+Linux+JavaEE】\n\n[【Java全栈】Java全栈学习路线及项目全资料总结【JavaSE+Web基础+大前端进阶+SSM+微服务+Linux+JavaEE】](https://blog.csdn.net/qq_45696377/article/details/110575362)\n','2021-08-25 10:22:03','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('13','1','【MyBatisPlus学习】乐观锁 OptimisticLockerInnerInterceptor插件 细解','【MyBatisPlus学习】乐观锁 OptimisticLockerInnerInterceptor插件 细解','@[TOC]\n# 乐观锁 \n\n**OptimisticLockerInnerInterceptor**\n\n> **乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题， 再次更新值测试**\n\n> **悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！**\n\n我们这里主要讲解 乐观锁机制！\n\n乐观锁实现方式：\n\n当要更新一条记录的时候，希望这条记录没有被别人更新\n乐观锁实现方式：\n\n - 取出记录时，获取当前version\n - 更新时，带上这个version\n - 执行更新时， set version = newVersion where version = oldVersion\n - 如果version不对，就更新失败\n\n\n```sql\n乐观锁：1、先查询，获得版本号 version = 1 \n-- A \nupdate user set name = \"maomao\", \nversion = version + 1 \nwhere id = 2 and version = 1 \n-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！\n update user set name = \"maomao\", \n version = version + 1 where id = 2 and version = 1\n```\n\n# 测试一下MP的乐观锁插件\n\n## 1、给数据库中增加version字段！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/087fdb4fa6b64256af0719fbf1704842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n## 2、我们实体类加对应的字段\n\n```sql\n@Version //乐观锁Version注解 \nprivate Integer version; \n```\n\n## 3、注册组件\n\n```java\n// 扫描我们的 mapper 文件夹\n@MapperScan(\"com.mao.mapper\")\n@EnableTransactionManagement    //自动管理事务的注解\n@Configuration // 配置类\npublic class MyBatisPlusConfig {\n\n    // 注册乐观锁插件\n    @Bean\n    public OptimisticLockerInterceptor optimisticLockerInterceptor() {\n        return new OptimisticLockerInterceptor();\n    }\n```\n\n## 4、测试一下\n\n```java\n// 测试乐观锁成功！\n    @Test\n    public void testOptimisticLocker(){\n        // 1、查询用户信息\n        User user = userMapper.selectById(1L);\n        // 2、修改用户信息\n        user.setName(\"maomao\");\n        user.setEmail(\"24736743@qq.com\");\n        // 3、执行更新操作\n        userMapper.updateById(user);\n    }\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5dbbfca5a00340fc99581b30302286dd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n\n```java\n// 测试乐观锁失败！多线程下\n    @Test\n    public void testOptimisticLocker2(){\n\n        // 线程 1\n        User user = userMapper.selectById(1L);\n        user.setName(\"maomao111\");\n        user.setEmail(\"24736743@qq.com\");\n\n        // 模拟另外一个线程执行了插队操作\n        User user2 = userMapper.selectById(1L);\n        user2.setName(\"maomao222\");\n        user2.setEmail(\"24736743@qq.com\");\n        userMapper.updateById(user2);\n\n        // 自旋锁来多次尝试提交！\n        userMapper.updateById(user); // 如果没有乐观锁就会覆盖插队线程的值！\n    }\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6aba9015a9a347ee8b9830b65d6f2c23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1Njk2Mzc3,size_16,color_FFFFFF,t_70)\n\n# 更多相关文章点这里\n\n[【Java全栈】Java全栈学习路线及项目全资料总结【JavaSE+Web基础+大前端进阶+SSM+微服务+Linux+JavaEE】](https://blog.csdn.net/qq_45696377/article/details/110575362)\n\n','2021-08-25 10:23:33','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('14','1','【Springboot学习】Shiro快速入门及与SpringBoot集成','【Springboot学习】Shiro快速入门及与SpringBoot集成','@[TOC](目录)\n# 1、Shiro简介\n\n## 1.1、Shiro 是什么？\n\n- Apache Shiro 是 Java 的一个安全（权限）框架。\n\n- Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。\n\n- Shiro 可以完成：认证、授权、加密、会话管理、与Web 集成、缓存等。\n- 下载地址\n  - 官网：[http://shiro.apache.org/](http://shiro.apache.org/)\n  - github：[https://github.com/apache/shiro](https://github.com/apache/shiro)\n\n\n\n## 1.2、有哪些功能？\n\n![image-20200729114647110](https://img-blog.csdnimg.cn/img_convert/26c200202f5d03ffd5b52f78bc7c3301.png)\n\n- Authentication:身份认证/登录，验证用户是不是拥有相应的身份\n\n- Authorization:授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限\n\n- Session Management:会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境，也可以是Web 环境的\n\n- Cryptography:加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储\n\n- Web Support:Web 支持，可以非常容易的集成到Web 环境\n\n- Caching:缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率\n\n- Concurrency:Shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去\n\n- Testing:提供测试支持\n\n- \"Run As\":允许一个用户假装为另一个用户（如果他们允许）的身份进行访问\n\n- Remember Me:记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了\n\n## 1.3、Shiro架构(外部)\n\n从外部来看Shiro，即从应用程序角度的来观察如何使用Shiro完成工作\n\n![image-20200729114702566](https://img-blog.csdnimg.cn/img_convert/4915e93b9d91979c3532412175ff59fa.png)\n\n- Subject：应用代码直接交互的对象是Subject，也就是说Shiro的对外API 核心就是Subject。Subject 代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；与Subject 的所有交互都会委托给SecurityManager；Subject 其实是一个门面，SecurityManager才是实际的执行者\n\n- SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且其管理着所有Subject；可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC中DispatcherServlet的角色\n\n- Realm：Shiro从Realm 获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm 看成DataSource\n\n## 1.4、Shiro架构(内部)\n\n![image-20200729114720578](https://img-blog.csdnimg.cn/img_convert/8d8c268aa1b1b156d8764f484eb12233.png)\n\n- Subject：任何可以与应用交互的“用户”；\n- SecurityManager：相当于SpringMVC中的DispatcherServlet；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证、授权、会话及缓存的管理。\n- Authenticator：负责Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了；\n- Authorizer：授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；\n- Realm：可以有1 个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC 实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的Realm；\n- SessionManager：管理Session 生命周期的组件；而Shiro并不仅仅可以用在Web 环境，也可以用在如普通的JavaSE环境\n  CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能\n- Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密。\n\n# 2、Hello World\n\n## 2.1、快速实践\n\n- 查看官方文档：http://shiro.apache.org/tutorial.html\n\n- 官方的quickstart : https://github.com/apache/shiro/tree/master/samples/quickstart/\n\n  ![image-20200729115148574](https://img-blog.csdnimg.cn/img_convert/0bc7c52506712197f94c9389bff03063.png)\n\n1. 创建一个maven父工程，用来学习Shiro,删掉不必要的部分\n\n2. 创建一个普通的Maven子工程：hell-shiro\n\n   ![image-20200729120114648](https://img-blog.csdnimg.cn/img_convert/e94b5b7f06ad4c9bab4e531113c84778.png)\n\n3. 根据[官方文档](https://github.com/apache/shiro/blob/master/samples/quickstart/pom.xml)，我们导入Shiro的依赖\n\n   ![image-20200729120207730](https://img-blog.csdnimg.cn/img_convert/17a00ec81c5627f08b08b1daea43c579.png)\n\n   \n\n   [版本号点击这里](https://mvnrepository.com/artifact/org.apache.shiro/shiro-core)\n\n   ```xml\n   <dependencies>\n       <dependency>\n           <groupId>org.apache.shiro</groupId>\n           <artifactId>shiro-core</artifactId>\n           <version>1.5.3</version>\n       </dependency>\n   \n       <!-- configure logging -->\n       <dependency>\n           <groupId>org.slf4j</groupId>\n           <artifactId>jcl-over-slf4j</artifactId>\n           <version>1.7.26</version>\n       </dependency>\n       <dependency>\n           <groupId>org.slf4j</groupId>\n           <artifactId>slf4j-log4j12</artifactId>\n           <version>1.7.26</version>\n       </dependency>\n       <dependency>\n           <groupId>log4j</groupId>\n           <artifactId>log4j</artifactId>\n           <version>1.2.17</version>\n       </dependency>\n   </dependencies>\n   ```\n\n4. 相关配置文件\n\n   - log4j.properties——[官网](https://github.com/apache/shiro/blob/master/samples/quickstart/src/main/resources/log4j.properties)\n\n     ```properties\n     log4j.rootLogger=INFO, stdout\n     \n     log4j.appender.stdout=org.apache.log4j.ConsoleAppender\n     log4j.appender.stdout.layout=org.apache.log4j.PatternLayout\n     log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n\n     \n     # General Apache libraries\n     log4j.logger.org.apache=WARN\n     \n     # Spring\n     log4j.logger.org.springframework=WARN\n     \n     # Default Shiro logging\n     log4j.logger.org.apache.shiro=INFO\n     \n     # Disable verbose logging\n     log4j.logger.org.apache.shiro.util.ThreadContext=WARN\n     log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN\n     ```\n\n   - shiro.ini——[官网](https://github.com/apache/shiro/blob/master/samples/quickstart/src/main/resources/shiro.ini)\n\n     ```ini\n     [users]\n     # user \'root\' with password \'secret\' and the \'admin\' role\n     root = secret, admin\n     # user \'guest\' with the password \'guest\' and the \'guest\' role\n     guest = guest, guest\n     # user \'presidentskroob\' with password \'12345\' (\"That\'s the same combination on\n     # my luggage!!!\" ;)), and role \'president\'\n     presidentskroob = 12345, president\n     # user \'darkhelmet\' with password \'ludicrousspeed\' and roles \'darklord\' and \'schwartz\'\n     darkhelmet = ludicrousspeed, darklord, schwartz\n     # user \'lonestarr\' with password \'vespa\' and roles \'goodguy\' and \'schwartz\'\n     lonestarr = vespa, goodguy, schwartz\n     \n     # -----------------------------------------------------------------------------\n     # Roles with assigned permissions\n     # \n     # Each line conforms to the format defined in the\n     # org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc\n     # -----------------------------------------------------------------------------\n     [roles]\n     # \'admin\' role has all permissions, indicated by the wildcard \'*\'\n     admin = *\n     # The \'schwartz\' role can do anything (*) with any lightsaber:\n     schwartz = lightsaber:*\n     # The \'goodguy\' role is allowed to \'drive\' (action) the winnebago (type) with\n     # license plate \'eagle5\' (instance specific id)\n     goodguy = winnebago:drive:eagle5\n     ```\n\n   - 启动类 Quickstart——[官网](https://github.com/apache/shiro/blob/master/samples/quickstart/src/main/java/Quickstart.java)\n\n     ```java\n     /*\n      * Licensed to the Apache Software Foundation (ASF) under one\n      * or more contributor license agreements.  See the NOTICE file\n      * distributed with this work for additional information\n      * regarding copyright ownership.  The ASF licenses this file\n      * to you under the Apache License, Version 2.0 (the\n      * \"License\"); you may not use this file except in compliance\n      * with the License.  You may obtain a copy of the License at\n      *\n      *     http://www.apache.org/licenses/LICENSE-2.0\n      *\n      * Unless required by applicable law or agreed to in writing,\n      * software distributed under the License is distributed on an\n      * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n      * KIND, either express or implied.  See the License for the\n      * specific language governing permissions and limitations\n      * under the License.\n      */\n     \n     import org.apache.shiro.SecurityUtils;\n     import org.apache.shiro.authc.*;\n     import org.apache.shiro.config.IniSecurityManagerFactory;\n     import org.apache.shiro.mgt.SecurityManager;\n     import org.apache.shiro.session.Session;\n     import org.apache.shiro.subject.Subject;\n     import org.apache.shiro.util.Factory;\n     import org.slf4j.Logger;\n     import org.slf4j.LoggerFactory;\n     \n     \n     /**\n      * Simple Quickstart application showing how to use Shiro\'s API.\n      * 简单入门Shiro使用API\n      *\n      * @since 0.9 RC2\n      */\n     public class Quickstart {\n     \n         private static final transient Logger log = LoggerFactory.getLogger(Quickstart.class);\n     \n     \n         public static void main(String[] args) {\n     \n             // The easiest way to create a Shiro SecurityManager with configured\n             // realms, users, roles and permissions is to use the simple INI config.\n             // We\'ll do that by using a factory that can ingest a .ini file and\n             // return a SecurityManager instance:\n     \n             // Use the shiro.ini file at the root of the classpath\n             // (file: and url: prefixes load from files and urls respectively):\n             // 读取配置文件:\n             Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n             SecurityManager securityManager = factory.getInstance();\n     \n             // for this simple example quickstart, make the SecurityManager\n             // accessible as a JVM singleton.  Most applications wouldn\'t do this\n             // and instead rely on their container configuration or web.xml for\n             // webapps.  That is outside the scope of this simple quickstart, so\n             // we\'ll just do the bare minimum so you can continue to get a feel\n             // for things.\n             SecurityUtils.setSecurityManager(securityManager);\n     \n             // Now that a simple Shiro environment is set up, let\'s see what you can do:\n     \n             // get the currently executing user:\n             // 获取当前的用户对象 Subject\n             Subject currentUser = SecurityUtils.getSubject();\n     \n             // Do some stuff with a Session (no need for a web or EJB container!!!)\n             //通过当前用户拿到Shiro的Session 可以脱离web存值取值\n             Session session = currentUser.getSession();\n             session.setAttribute(\"someKey\", \"aValue\");\n             String value = (String) session.getAttribute(\"someKey\");\n             if (value.equals(\"aValue\")) {\n                 log.info(\"Retrieved the correct value! [\" + value + \"]\");\n             }\n     \n             // let\'s login the current user so we can check against roles and permissions:\n             //判断当前的用户是否被认证\n             if (!currentUser.isAuthenticated()) {\n                 //Token 令牌\n                 UsernamePasswordToken token = new UsernamePasswordToken(\"lonestarr\", \"vespa\");\n                 //设置记住我\n                 token.setRememberMe(true);\n                 try {\n                     //执行登录操作\n                     currentUser.login(token);\n                 } catch (UnknownAccountException uae) {\n                     log.info(\"There is no user with username of \" + token.getPrincipal());\n                 } catch (IncorrectCredentialsException ice) {\n                     log.info(\"Password for account \" + token.getPrincipal() + \" was incorrect!\");\n                 } catch (LockedAccountException lae) {\n                     log.info(\"The account for username \" + token.getPrincipal() + \" is locked.  \" +\n                             \"Please contact your administrator to unlock it.\");\n                 }\n                 // ... catch more exceptions here (maybe custom ones specific to your application?\n                 catch (AuthenticationException ae) {\n                     //unexpected condition?  error?\n                 }\n             }\n     \n             //say who they are:\n             //print their identifying principal (in this case, a username):\n             log.info(\"User [\" + currentUser.getPrincipal() + \"] logged in successfully.\");\n     \n             //test a role:\n             // 检查角色\n             if (currentUser.hasRole(\"schwartz\")) {\n                 log.info(\"May the Schwartz be with you!\");\n             } else {\n                 log.info(\"Hello, mere mortal.\");\n             }\n     \n             //test a typed permission (not instance-level)\n             //粗粒度\n             if (currentUser.isPermitted(\"lightsaber:wield\")) {\n                 log.info(\"You may use a lightsaber ring.  Use it wisely.\");\n             } else {\n                 log.info(\"Sorry, lightsaber rings are for schwartz masters only.\");\n             }\n     \n             //a (very powerful) Instance Level permission:\n             //细粒度\n             if (currentUser.isPermitted(\"winnebago:drive:eagle5\")) {\n                 log.info(\"You are permitted to \'drive\' the winnebago with license plate (id) \'eagle5\'.  \" +\n                         \"Here are the keys - have fun!\");\n             } else {\n                 log.info(\"Sorry, you aren\'t allowed to drive the \'eagle5\' winnebago!\");\n             }\n     \n             //all done - log out!\n             //注销\n             currentUser.logout();\n     \n             //结束\n             System.exit(0);\n         }\n     }\n     ```\n\n     ![image-20200729130649625](https://img-blog.csdnimg.cn/img_convert/47981bf3bbea556ab1c7a086e85bb024.png)\n\n   - Spring Secutrry都有~（只是换了个名字）\n\n     ```java\n     // 获取当前的用户对象 Subject\n     Subject currentUser = SecurityUtils.getSubject();\n     Session session = currentUser.getSession();\n     currentUser.isAuthenticated()\n         currentUser.getPrincipal()\n         currentUser.hasRole(\"schwartz\")\n         currentUser.isPermitted(\"lightsaber:wield\")\n         currentUser.logout();\n     ```\n\n\n\n# 3、SpringBoot集成\n\n## 3.1、SpringBoot整合Shiro环境搭建\n\n1. 新建一个项目或模块，勾选依赖\n\n   ![image-20200729174715011](https://img-blog.csdnimg.cn/img_convert/abab859655a176b531ff7fca2d2b62cb.png)\n\n   pom.xml\n\n   ```xml\n   <dependencies>\n       <!--thymeleaf-->\n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-thymeleaf</artifactId>\n       </dependency>\n   \n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-web</artifactId>\n       </dependency>\n   \n       <dependency>\n           <groupId>org.springframework.boot</groupId>\n           <artifactId>spring-boot-starter-test</artifactId>\n           <scope>test</scope>\n           <exclusions>\n               <exclusion>\n                   <groupId>org.junit.vintage</groupId>\n                   <artifactId>junit-vintage-engine</artifactId>\n               </exclusion>\n           </exclusions>\n       </dependency>\n   </dependencies>\n   ```\n\n2. 测试环境是否正常\n\n   - 新建一个controller页面\n\n     ```java\n     @Controller\n     public class MyController {\n     \n         @RequestMapping({\"/\",\"/index\"})\n         public String toIndex(Model model) {\n             model.addAttribute(\"msg\",\"hello,Shiro\");\n             return \"index\";\n         }\n         \n         @RequestMapping(\"/user/add\")\n         public String add() {\n             return \"user/add\";\n         }\n     \n         @RequestMapping(\"/user/update\")\n         public String update() {\n             return \"user/update\";\n     	}\n     }\n     ```\n\n   - 新建一个index.html页面\n\n     ```html\n     <!DOCTYPE html>\n     <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n     <head>\n         <meta charset=\"UTF-8\">\n         <title>首页</title>\n     </head>\n     <body>\n     <div>\n         <h1>首页</h1>\n         <p th:text=\"${msg}\"></p>\n     \n         <hr>\n         <a th:href=\"@{/user/add}\">add</a>   | <a th:href=\"@{/user/update}\">update</a>\n     </div>\n     </body>\n     </html>\n     ```\n\n   - 新建一个add.html页面\n\n     ```html\n     <!DOCTYPE html>\n     <html lang=\"en\">\n     <head>\n         <meta charset=\"UTF-8\">\n         <title>Title</title>\n     </head>\n     <body>\n         <h1>add</h1>\n     </body>\n     </html>\n     ```\n\n   - 新建一个update.html页面\n\n     ```html\n     <!DOCTYPE html>\n     <html lang=\"en\">\n     <head>\n         <meta charset=\"UTF-8\">\n         <title>Title</title>\n     </head>\n     <body>\n         <h1>update</h1>\n     </body>\n     </html>\n     ```\n\n   - 项目结构\n\n     ![image-20200729190325307](https://img-blog.csdnimg.cn/img_convert/466324d509f6a828585a4be6d4679e90.png)\n\n   - 运行截图\n\n     ![image-20200729190548307](https://img-blog.csdnimg.cn/img_convert/68373fda638c7763a109a885fc0b5508.png)\n\n3. 导入shiro整合spring的包——[官网](https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring),查看最新版本\n\n   ```xml\n   <!--\n         Subject  用户\n         SecurityManager 管理所有用户\n         Realm 连接数据库\n   -->\n   \n   <!--shiro整合spring的包-->\n   <dependency>\n       <groupId>org.apache.shiro</groupId>\n       <artifactId>shiro-spring</artifactId>\n       <version>1.5.3</version>\n   </dependency>\n   ```\n\n4. 编写导入配置类\n\n   - 编写一个自定义类UserRealm\n\n     ```java\n     //自定义的UserRealm\n     public class UserRealm extends AuthorizingRealm {\n         //授权\n         @Override\n         protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n             System.out.println(\"执行了=>授权doGetAuthorizationInfo\");\n             return null;\n         }\n     \n         //认证\n         @Override\n         protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n             System.out.println(\"执行了=>认证doGetAuthorizationInfo\");\n             return null;\n         }\n     }\n     ```\n\n   - 编写配置ShiroConfig\n\n     - 创建realm对象，需要自定义类\n     - DefaultWebSecurityManager\n     - ShiroFilterFactoryBean\n\n     ```java\n     @Configuration\n     public class ShiroConfig {\n     \n         //3. shiroFilterFactoryBean\n     \n         @Bean\n         public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager) {\n             ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n             // 设置安全管理器\n             bean.setSecurityManager(defaultWebSecurityManager);\n     \n             return bean;\n         }\n     \n         //2. DefaultWebSecurityManager\n     \n         @Bean\n         public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) {\n             DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n     \n             // 关联userRealm\n             securityManager.setRealm(userRealm);\n             return securityManager;\n         }\n         //1. 创建realm对象，需要自定义类\n     \n         @Bean\n         public UserRealm userRealm() {\n             return new UserRealm();\n         }\n     }\n     ```\n\n## 3.2、Shiro实现登录拦截\n\n- 在`ShiroConfig`中的`getShiroFilterFactoryBean`方法中添加如下配置\n\n    - anon： 无需认证就可以访问\n    - authc： 必须认证了才能访问\n    - user： 必须拥有记住我功能才能用\n    - perms： 拥有对某个资源的权限才能访问\n    - role： 拥有某个角色权限\n\n    ```java\n    Map<String, String> filterMap = new LinkedHashMap<>();\n    filterMap.put(\"/user/add\",\"authc\");\n    filterMap.put(\"/user/update\",\"authc\");\n    bean.setFilterChainDefinitionMap(filterMap);\n    ```\n\n- 点击首页的add或者update之后\n\n  ![image-20200729191619576](https://img-blog.csdnimg.cn/img_convert/c9f9fefb4da860b0673c1b429afe13cb.png)\n\n- 添加拦截成功页面\n  - 登录页面login.html\n\n    ```html\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>登录页面</title>\n    </head>\n    <body>\n    <h1>登录</h1>\n    <hr>\n\n    <form action=\"\">\n        <p>用户名：<input type=\"text\" name=\"username\"></p>\n        <p>密码：<input type=\"text\" name=\"password\"></p>\n        <p>密码：<input type=\"submit\"></p>\n    </form>\n    </body>\n    </html>\n    ```\n\n  - 在MyConfig中添加\n  \n      ```java\n      @RequestMapping(\"/toLogin\")\n      public String toLogin() {\n          return \"login\";\n      }\n      ```\n  \n  - 在`ShiroConfig`中的`getShiroFilterFactoryBean`方法中添加如下配置\n  \n      ```java\n      //设置登录的请求\n      bean.setLoginUrl(\"/toLogin\");\n      ```\n  \n- 拦截成功页面\n\n  ![image-20200729192409085](https://img-blog.csdnimg.cn/img_convert/fbf81af4b24493e6fc3cd0fff1ffe377.png)\n\n## 3.3、Shiro实现用户认证\n\n1. 在`MyController`中编写用户提交表单之后处理\n\n   ```java\n   @RequestMapping(\"/login\")\n   public String login(String username, String password, Model model) {\n       //获取一个用户\n       Subject subject = SecurityUtils.getSubject();\n       // 封装用户的登录数据\n       UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n   \n       try {\n           subject.login(token);//执行登录的方法，如果没有异常就说明ok了\n           return \"index\";\n       } catch (UnknownAccountException e) {//用户名不存在\n           model.addAttribute(\"msg\",\"用户名错误\");\n           return \"login\";\n       } catch (IncorrectCredentialsException e) {//密码不存在\n           model.addAttribute(\"msg\",\"密码错误\");\n           return \"login\";\n       }\n   \n   }\n   ```\n\n2. login.html的修改\n\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   <head>\n       <meta charset=\"UTF-8\">\n       <title>登录页面</title>\n   </head>\n   <body>\n   <h1>登录</h1>\n   <hr>\n   \n   <p th:text=\"${msg}\" style=\"color: red;\"></p>\n   <form th:action=\"@{/login}\">\n       <p>用户名：<input type=\"text\" name=\"username\"></p>\n       <p>密码：<input type=\"text\" name=\"password\"></p>\n       <p>密码：<input type=\"submit\"></p>\n   </form>\n   </body>\n   </html>\n   ```\n\n3. 用户输入登录信息\n\n   - 页面\n\n     ![image-20200729220647520](https://img-blog.csdnimg.cn/img_convert/31a223e1775bfcd4097a680c30b5a0e6.png)\n\n   - 控制台\n\n     ![image-20200729220926500](https://img-blog.csdnimg.cn/img_convert/5c3203b9c675c2fb6c121bd4cd33ab7c.png)\n\n4. 用户认证编写`UserRealm`中的认证（doGetAuthenticationInfo）\n\n   ```java\n   //认证\n   @Override\n   protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n       System.out.println(\"执行了=>认证doGetAuthorizationInfo\");\n       // 用户名、密码， 数据中取\n       String name = \"root\";\n       String password = \"123456\";\n   \n       UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n   \n       if (!userToken.getUsername().equals(name)) {\n           return null;//抛出异常 UnknownAccountException\n       }\n   \n       // 密码认证，shiro做\n       return new SimpleAuthenticationInfo(\"\",password,\"\");\n   }\n   ```\n\n## 3.4、Shiro整合Mybatis\n\n1. 导入依赖\n\n   ```xml\n   <dependency>\n       <groupId>org.projectlombok</groupId>\n       <artifactId>lombok</artifactId>\n   </dependency>\n   <dependency>\n       <groupId>mysql</groupId>\n       <artifactId>mysql-connector-java</artifactId>\n   </dependency>\n   \n   <dependency>\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n       <version>1.2.17</version>\n   </dependency>\n   \n   <dependency>\n       <groupId>com.alibaba</groupId>\n       <artifactId>druid</artifactId>\n       <version>1.1.23</version>\n   </dependency>\n   \n   <!--引入mybatis，这是MyBatis官方提供的适配spring Boot的，而不是spring Boot自己的-->\n   <dependency>\n       <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n       <version>2.1.3</version>\n   </dependency>\n   ```\n   \n2. 配置文件application.yml的编写\n\n   ```yml\n   spring:\n     datasource:\n       username: root\n       password: admin\n       #?serverTimezone=UTC解决时区的报错\n       url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\n       driver-class-name: com.mysql.cj.jdbc.Driver\n       type: com.alibaba.druid.pool.DruidDataSource\n   \n       #Spring Boot 默认是不注入这些属性值的，需要自己绑定\n       #druid 数据源专有配置\n       initialSize: 5\n       minIdle: 5\n       maxActive: 20\n       maxWait: 60000\n       timeBetweenEvictionRunsMillis: 60000\n       minEvictableIdleTimeMillis: 300000\n       validationQuery: SELECT 1 FROM DUAL\n       testWhileIdle: true\n       testOnBorrow: false\n       testOnReturn: false\n       poolPreparedStatements: true\n   \n       #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入\n       #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority\n       #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j\n       filters: stat,wall,log4j\n       maxPoolPreparedStatementPerConnectionSize: 20\n       useGlobalDataSourceStat: true\n       connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500\n       \n   mybatis:\n     type-aliases-package: nuc.ss.pojo\n     mapper-locations: classpath:mapper/*.xml\n   ```\n\n3. User类的编写\n\n   ```java\n   @Data\n   @AllArgsConstructor\n   @NoArgsConstructor\n   public class User {\n       private int id;\n       private String name;\n       private String pwd;\n   }\n   ```\n\n4. UserMapper.xml映射\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n   <!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n           \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n   <!--namespace=绑定一个对应的Dao/Mapper接口-->\n   <mapper namespace=\"nuc.ss.mapper.UserMapper\">\n       \n       <select id=\"queryUserList\" resultType=\"User\">\n           select * from mybatis.user;\n       </select>\n   \n       <select id=\"queryUserById\" resultType=\"User\">\n           select * from mybatis.user where id = #{id};\n       </select>\n   \n       <insert id=\"addUser\" parameterType=\"User\">\n           insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd});\n       </insert>\n   \n       <update id=\"updateUser\" parameterType=\"User\">\n           update mybatis.user set name=#{name},pwd = #{pwd} where id = #{id};\n       </update>\n   \n       <delete id=\"deleteUser\" parameterType=\"int\">\n           delete from mybatis.user where id = #{id}\n       </delete>\n   </mapper>\n   ```\n   \n5. UserService接口实现\n\n   ```java\n   public interface UserService {\n   \n       public User queryUserByName(String name);\n   }\n   ```\n\n6. UserServiceImpl业务逻辑\n\n   ```java\n   @Service\n   public class UserServiceImpl implements UserService {\n   \n       @Autowired\n       UserMapper userMapper;\n       @Override\n       public User queryUserByName(String name) {\n           return userMapper.queryUserByName(name);\n       }\n   }\n   \n   ```\n\n7. 测试环境\n\n   ```java\n   @SpringBootTest\n   class ShiroSpringbootApplicationTests {\n   \n       @Autowired\n       UserService userService;\n       @Test\n       void contextLoads() {\n           System.out.println(userService.queryUserByName(\"狂神\"));\n       }\n   \n   }\n   ```\n\n   ![image-20200730121720922](https://img-blog.csdnimg.cn/img_convert/95b7fe783a1a224b2f82ea424def887b.png)\n\n8. `UserRealm`连接真实数据库\n\n   ```java\n   //认证\n   @Override\n   protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n       System.out.println(\"执行了=>认证doGetAuthorizationInfo\");\n   \n       UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n       \n       // 真实数据库 用户名、密码， 数据中取\n       User user = userService.queryUserByName(userToken.getUsername());\n   \n       if (user == null) {//没有这个人\n           return null;\n       }\n   \n       // 密码认证，shiro做\n       return new SimpleAuthenticationInfo(\"\",user.getPwd(),\"\");\n   }\n   ```\n\n   ![image-20200730180019861](https://img-blog.csdnimg.cn/img_convert/1f6e567f6f2143870ee5bc047f6d0fd3.png)\n   \n9. 断点测试密码加密类型\n\n   - 打断点Debug\n\n     ![image-20200730182621912](https://img-blog.csdnimg.cn/img_convert/b9a727fd4f1b0e7bfc485eaae5e1f594.png)\n\n   - 默认是`SimpleCredentialsMatcher`加密\n\n     ![image-20200730181814293](https://img-blog.csdnimg.cn/img_convert/2f884afd2f7a9727a4a69453c7ea40be.png)\n\n   - MD5加密——[测试](http://tool.chinaz.com/tools/md5.aspx)\n\n     123456——E10ADC3949BA59ABBE56E057F20F883E\n\n   - MD5盐值加密\n\n   - 所有加密\n\n     ![image-20200730181944253](https://img-blog.csdnimg.cn/img_convert/ea500d77637cda2e17e3beecbc0fb125.png)\n\n## 3.5、Shiro实现用户授权\n\n1. `ShiroConfig`中的`getShiroFilterFactoryBean`方法添加认证代码\n\n   ```java\n   //授权，正常情况下，没有授权会跳转到为授权页面\n   filterMap.put(\"/user/add\",\"perms[user:add]\");\n   filterMap.put(\"/user/update\",\"perms[user:update]\");\n   ```\n\n2. 登录之后点击add按钮会弹出如下页面\n\n   ![image-20200730195133631](https://img-blog.csdnimg.cn/img_convert/9c0a17b27a9796d80ceb3aacbfdf7edc.png)\n\n3. 添加为授权页面\n\n   - MyController\n\n     ```java\n     @RequestMapping(\"/noauto\")\n     @ResponseBody\n     public String unauthorized() {\n         return \"未经授权，无法访问此页面\";\n     }\n     ```\n\n   - `ShiroConfig`中的`getShiroFilterFactoryBean`方法中添加\n\n     ```java\n     //为授权页面\n     bean.setUnauthorizedUrl(\"/noauto\");\n     ```\n\n4. 再次测试\n\n   ![image-20200730195807437](https://img-blog.csdnimg.cn/img_convert/998b16a316fa4c567276186b356b6bb1.png)\n\n   ![image-20200730195946692](https://img-blog.csdnimg.cn/img_convert/a9d57b4328c47a05adbe24bd7db51789.png)\n\n   所以需要在UserRealm中为用户进行真正授权\n\n5. UserRealm类的修改\n\n   ```java\n   //自定义的UserRealm\n   public class UserRealm extends AuthorizingRealm {\n   \n       @Autowired\n       UserService userService;\n       //授权\n       @Override\n       protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n           System.out.println(\"执行了=>授权doGetAuthorizationInfo\");\n   \n           SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n   \n           //拿到当前登录的这个对象\n           Subject subject = SecurityUtils.getSubject();\n           User currentUser = (User)subject.getPrincipal();//拿到user对象\n   \n           //设置当前用户的权限\n           info.addStringPermission(currentUser.getPerms());\n   \n           return info;\n       }\n   \n       //认证\n       @Override\n       protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n           ......\n           // 密码认证，shiro做\n           return new SimpleAuthenticationInfo(user,user.getPwd(),\"\");\n       }\n   }\n   \n   ```\n\n6. 再次测试\n\n   ![image-20200730202810034](https://img-blog.csdnimg.cn/img_convert/7e6190a52afeab6cace319c39eb5eba5.png)\n\n## 3.6、Shiro整合Thymeleaf\n\n1. shiro-thymeleaf整合包导入——[官网](https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro)\n\n   ```xml\n   <!--shiro-thymeleaf整合-->\n   <dependency>\n       <groupId>com.github.theborakompanioni</groupId>\n       <artifactId>thymeleaf-extras-shiro</artifactId>\n       <version>2.0.0</version>\n   </dependency>\n   ```\n\n2. 在ShiroConfig中整合ShiroDialect\n\n   ```java\n   // 整合ShiroDialect： 用来整合 Shiro thymeleaf\n   @Bean\n   public ShiroDialect getShiroDialect() {\n       return new ShiroDialect();\n   }\n   ```\n\n3. index.html页面\n\n   ```html\n   <!DOCTYPE html>\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\n         xmlns:shiro=\"http://www.thymeleaf.org/thymeleaf-extras-shiro\">\n   <head>\n       <meta charset=\"UTF-8\">\n       <title>首页</title>\n   </head>\n   <body>\n   \n   <div>\n       <h1>首页</h1>\n       <p th:text=\"${msg}\"></p>\n   \n       <!--用session实现，配合UserRealm中的session实现-->\n       <!--<div th:if=\"${session.loginUser==null}\">\n           <a th:href=\"@{/toLogin}\">登录</a>\n       </div>-->\n   \n       <div shiro:notAuthenticated>\n           <a th:href=\"@{/toLogin}\">登录</a>\n       </div>\n   \n       <hr>\n   \n       <div shiro:hasPermission=\"user:add\">\n           <a th:href=\"@{/user/add}\">add</a>\n       </div>\n   \n       <div shiro:hasPermission=\"user:update\">\n           <a th:href=\"@{/user/update}\">update</a>\n       </div>\n   \n   </div>\n   </body>\n   </html>\n   ```\n\n4. 页面显示\n\n   ![image-20200730205736153](https://img-blog.csdnimg.cn/img_convert/cefe790cf1badf59f036710875bd2855.png)\n\n## 3.7、所有代码\n\n- ShiroConfig\n\n  ```java\n  package nuc.ss.config;\n  \n  import at.pollux.thymeleaf.shiro.dialect.ShiroDialect;\n  import org.apache.shiro.spring.web.ShiroFilterFactoryBean;\n  import org.apache.shiro.web.mgt.DefaultWebSecurityManager;\n  import org.springframework.beans.factory.annotation.Qualifier;\n  import org.springframework.context.annotation.Bean;\n  import org.springframework.context.annotation.Configuration;\n  \n  import java.util.LinkedHashMap;\n  import java.util.Map;\n  \n  @Configuration\n  public class ShiroConfig {\n  \n      //shiroFilterFactoryBean\n  \n      @Bean\n      public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager) {\n          ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n          // 设置安全管理器\n          bean.setSecurityManager(defaultWebSecurityManager);\n  \n          // 添加shiro的内置过滤器\n          /*\n              anon： 无需认证就可以访问\n              authc： 必须认证了才能访问\n              user： 必须拥有记住我功能才能用\n              perms： 拥有对某个资源的权限才能访问\n              role： 拥有某个角色权限\n           */\n  \n          //拦截\n          Map<String, String> filterMap = new LinkedHashMap<>();\n          //filterMap.put(\"/user/add\",\"authc\");\n          //filterMap.put(\"/user/update\",\"authc\");\n  \n  \n          //授权，正常情况下，没有授权会跳转到为授权页面\n          filterMap.put(\"/user/add\",\"perms[user:add]\");\n          filterMap.put(\"/user/update\",\"perms[user:update]\");\n  \n          filterMap.put(\"/user/*\",\"authc\");\n  \n          bean.setFilterChainDefinitionMap(filterMap);\n  \n          //设置登录的请求\n          bean.setLoginUrl(\"/toLogin\");\n  \n          //为授权页面\n          bean.setUnauthorizedUrl(\"/noauto\");\n  \n        return bean;\n      }\n  \n      //DefaultWebSecurityManager\n  \n      @Bean\n      public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm) {\n          DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n  \n          // 关联userRealm\n          securityManager.setRealm(userRealm);\n          return securityManager;\n      }\n      //创建realm对象，需要自定义类\n  \n      @Bean\n      public UserRealm userRealm() {\n          return new UserRealm();\n      }\n  \n      // 整合ShiroDialect： 用来整合 Shiro thymeleaf\n      @Bean\n      public ShiroDialect getShiroDialect() {\n          return new ShiroDialect();\n      }\n  }\n  ```\n\n- UserRealm\n\n  ```java\n  package nuc.ss.config;\n  \n  import nuc.ss.pojo.User;\n  import nuc.ss.service.UserService;\n  import org.apache.shiro.SecurityUtils;\n  import org.apache.shiro.authc.*;\n  import org.apache.shiro.authz.AuthorizationInfo;\n  import org.apache.shiro.authz.SimpleAuthorizationInfo;\n  import org.apache.shiro.realm.AuthorizingRealm;\n  import org.apache.shiro.session.Session;\n  import org.apache.shiro.subject.PrincipalCollection;\n  import org.apache.shiro.subject.Subject;\n  import org.springframework.beans.factory.annotation.Autowired;\n  \n  //自定义的UserRealm\n  public class UserRealm extends AuthorizingRealm {\n  \n      @Autowired\n      UserService userService;\n      //授权\n      @Override\n      protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n          System.out.println(\"执行了=>授权doGetAuthorizationInfo\");\n  \n          SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n  \n          //info.addStringPermission(\"user:add\");\n  \n          //拿到当前登录的这个对象\n          Subject subject = SecurityUtils.getSubject();\n          User currentUser = (User)subject.getPrincipal();//拿到user对象\n  \n          //设置当前用户的权限\n          info.addStringPermission(currentUser.getPerms());\n  \n          return info;\n      }\n  \n      //认证\n      @Override\n      protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n          System.out.println(\"执行了=>认证doGetAuthorizationInfo\");\n  \n          UsernamePasswordToken userToken = (UsernamePasswordToken) token;\n  \n          // 虚拟用户\n          //String name = \"root\";\n          //String password = \"123456\";\n          //if (!userToken.getUsername().equals(name)) {\n          //    return null;//抛出异常 UnknownAccountException\n          //}\n  \n          // 真实数据库 用户名、密码， 数据中取\n          User user = userService.queryUserByName(userToken.getUsername());\n  \n          if (user == null) {//没有这个人\n              return null;\n          }\n  \n          //首页\n          //Subject currentSubject = SecurityUtils.getSubject();\n          //Session session = currentSubject.getSession();\n          //session.setAttribute(\"loginUser\",user);\n  \n  \n          // 密码认证，shiro做\n          return new SimpleAuthenticationInfo(user,user.getPwd(),\"\");\n      }\n  }\n  ```\n\n- MyController\n\n  ```java\n  package nuc.ss.controller;\n  \n  import org.apache.shiro.SecurityUtils;\n  import org.apache.shiro.authc.IncorrectCredentialsException;\n  import org.apache.shiro.authc.UnknownAccountException;\n  import org.apache.shiro.authc.UsernamePasswordToken;\n  import org.apache.shiro.subject.Subject;\n  import org.springframework.stereotype.Controller;\n  import org.springframework.ui.Model;\n  import org.springframework.web.bind.annotation.RequestMapping;\n  import org.springframework.web.bind.annotation.ResponseBody;\n  \n  @Controller\n  public class MyController {\n  \n      @RequestMapping({\"/\",\"/index\"})\n      public String toIndex(Model model) {\n          model.addAttribute(\"msg\",\"hello,Shiro\");\n          return \"index\";\n      }\n  \n      @RequestMapping(\"/user/add\")\n      public String add() {\n          return \"user/add\";\n      }\n  \n      @RequestMapping(\"/user/update\")\n      public String update() {\n          return \"user/update\";\n      }\n  \n      @RequestMapping(\"/toLogin\")\n      public String toLogin() {\n          return \"login\";\n      }\n  \n      @RequestMapping(\"/login\")\n      public String login(String username, String password, Model model) {\n          //获取一个用户\n          Subject subject = SecurityUtils.getSubject();\n          // 封装用户的登录数据\n          UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n  \n          try {\n              subject.login(token);//执行登录的方法，如果没有异常就说明ok了\n              return \"index\";\n          } catch (UnknownAccountException e) {//用户名不存在\n              model.addAttribute(\"msg\",\"用户名错误\");\n              return \"login\";\n          } catch (IncorrectCredentialsException e) {//密码不存在\n              model.addAttribute(\"msg\",\"密码错误\");\n              return \"login\";\n          }\n      }\n  \n      @RequestMapping(\"/noauto\")\n      @ResponseBody\n      public String unauthorized() {\n          return \"未经授权，无法访问此页面\";\n      }\n  }\n  \n  ```\n\n- pom依赖\n\n  ```xml\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n      <modelVersion>4.0.0</modelVersion>\n      <groupId>nuc.ss</groupId>\n      <artifactId>shiro-springboot</artifactId>\n      <version>0.0.1-SNAPSHOT</version>\n      <name>shiro-springboot</name>\n      <description>Demo project for Spring Boot</description>\n  \n      <properties>\n          <java.version>1.8</java.version>\n          <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n          <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n          <spring-boot.version>2.3.0.RELEASE</spring-boot.version>\n      </properties>\n  \n      <dependencies>\n  \n          <!--\n              Subject  用户\n              SecurityManager 管理所有用户\n              Realm 连接数据库\n          -->\n  \n          <!--shiro-thymeleaf整合-->\n          <!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro -->\n          <dependency>\n              <groupId>com.github.theborakompanioni</groupId>\n              <artifactId>thymeleaf-extras-shiro</artifactId>\n              <version>2.0.0</version>\n          </dependency>\n  \n          <dependency>\n              <groupId>org.projectlombok</groupId>\n              <artifactId>lombok</artifactId>\n          </dependency>\n          <dependency>\n              <groupId>mysql</groupId>\n              <artifactId>mysql-connector-java</artifactId>\n          </dependency>\n  \n          <dependency>\n              <groupId>log4j</groupId>\n              <artifactId>log4j</artifactId>\n              <version>1.2.17</version>\n          </dependency>\n  \n          <dependency>\n              <groupId>com.alibaba</groupId>\n              <artifactId>druid</artifactId>\n              <version>1.1.23</version>\n          </dependency>\n  \n          <!--引入mybatis，这是MyBatis官方提供的适配spring Boot的，而不是spring Boot自己的-->\n          <dependency>\n              <groupId>org.mybatis.spring.boot</groupId>\n              <artifactId>mybatis-spring-boot-starter</artifactId>\n              <version>2.1.3</version>\n          </dependency>\n  \n          <!--shiro整合spring的包-->\n          <dependency>\n              <groupId>org.apache.shiro</groupId>\n              <artifactId>shiro-spring</artifactId>\n              <version>1.5.3</version>\n          </dependency>\n          <!--thymeleaf-->\n          <dependency>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-starter-thymeleaf</artifactId>\n          </dependency>\n  \n          <dependency>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-starter-web</artifactId>\n          </dependency>\n  \n          <dependency>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-starter-test</artifactId>\n              <scope>test</scope>\n              <exclusions>\n                  <exclusion>\n                      <groupId>org.junit.vintage</groupId>\n                      <artifactId>junit-vintage-engine</artifactId>\n                  </exclusion>\n              </exclusions>\n          </dependency>\n      </dependencies>\n  \n      <dependencyManagement>\n          <dependencies>\n              <dependency>\n                  <groupId>org.springframework.boot</groupId>\n                  <artifactId>spring-boot-dependencies</artifactId>\n                  <version>${spring-boot.version}</version>\n                  <type>pom</type>\n                  <scope>import</scope>\n              </dependency>\n          </dependencies>\n      </dependencyManagement>\n  \n      <build>\n          <plugins>\n              <plugin>\n                  <groupId>org.apache.maven.plugins</groupId>\n                  <artifactId>maven-compiler-plugin</artifactId>\n                  <configuration>\n                      <source>1.8</source>\n                      <target>1.8</target>\n                      <encoding>UTF-8</encoding>\n                  </configuration>\n              </plugin>\n              <plugin>\n                  <groupId>org.springframework.boot</groupId>\n                  <artifactId>spring-boot-maven-plugin</artifactId>\n              </plugin>\n          </plugins>\n      </build>\n  \n  </project>\n  \n  ```\n\n  \n\n# 4、完美的解释\n\n[让 Apache Shiro 保护你的应用](https://www.infoq.cn/article/apache-shiro/?itm_source=infoq_en&itm_medium=link_on_en_item&itm_campaign=item_in_other_langs)','2021-08-25 10:24:37','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('15','1','【Springboot学习】SpringBoot集成Shiro前后端分离使用redis做缓存【个人博客搭建】','【Springboot学习】SpringBoot集成Shiro前后端分离使用redis做缓存【个人博客搭建】','# shiro-redis\n@[TOC](目录)\n\n[ alexxiyang / shiro-redis](https://travis-ci.org/github/alexxiyang/shiro-redis)\n\nshiro 只提供 ehcache 和 concurrentHashMap 的支持。这里有一个 shiro 可以使用的 redis 缓存实现。希望它会帮助你！\n\n# 下载\n\n您可以使用以下 2 种方式之一包含`shiro-redis`到您的项目中\n\n- 用于`git clone https://github.com/alexxiyang/shiro-redis.git`将项目克隆到本地工作区并自行构建 jar 文件\n- 添加maven依赖\n\n```\n<dependency>\n    <groupId>org.crazycake</groupId>\n    <artifactId>shiro-redis</artifactId>\n    <version>3.3.1</version>\n</dependency>\n```\n\n> **注意：**\n> 3.3.0 错误地在java11 中编译。请使用java8编译的3.3.1\n\n## shiro-core/jedis 版本对比图\n\n|  shiro-redis   | **shiro** | **jedis** |\n| :------------: | :-------: | :-------: |\n|     3.2.3      |   1.3.2   |   2.9.0   |\n| 3.3.0 (java11) |   1.6.0   |   3.3.0   |\n| 3.3.1 (java8)  |   1.6.0   |   3.3.0   |\n\n# 使用前\n\n这是您需要了解的第一件事。Shiro-redis 需要一个 id 字段来标识您在 Redis 中的授权对象。所以请确保你的主类有一个字段，你可以得到这个对象的唯一 id。请通过以下方式设置此 ID 字段名称`cacheManager.principalIdFieldName = <your id field name of principal object>`\n\n例如：\n\n如果你这样创建`SimpleAuthenticationInfo`：\n\n```\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken)token;\n    UserInfo userInfo = new UserInfo();\n    userInfo.setUsername(usernamePasswordToken.getUsername());\n    return new SimpleAuthenticationInfo(userInfo, \"123456\", getName());\n}\n```\n\n那么`userInfo`对象就是你的主要对象。您需要确保`UserInfo`Redis 有一个唯一的字段来识别它。以`userId`为例：\n\n```\npublic class UserInfo implements Serializable{\n\n    private Integer userId\n\n    private String username;\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Integer getUserId() {\n        return this.userId;\n    }\n}\n```\n\n将 userId 作为 的值`cacheManager.principalIdFieldName`，如下所示：\n\n```\ncacheManager.principalIdFieldName = userId\n```\n\n如果你使用的是 Spring，配置应该是\n\n```\n<property name=\"principalIdFieldName\" value=\"userId\" />\n```\n\n然后`shiro-redis`将调用`userInfo.getUserId()`获取 id 以保存 Redis 对象。\n\n# 如何配置？\n\n您可以配置`shiro-redis`in`shiro.ini`或 in`spring-*.xml`\n\n## 设置文件\n\n下面是 shiro.ini 的配置示例。\n\n### Redis 独立\n\n如果您在独立模式下运行 Redis\n\n```\n[main]\n#====================================\n# shiro-redis configuration [start]\n#====================================\n\n#===================================\n# Redis Manager [start]\n#===================================\n\n# Create redisManager\nredisManager = org.crazycake.shiro.RedisManager\n\n# Redis host. If you don\'t specify host the default value is 127.0.0.1:6379\nredisManager.host = 127.0.0.1:6379\n\n#===================================\n# Redis Manager [end]\n#===================================\n\n#=========================================\n# Redis session DAO [start]\n#=========================================\n\n# Create redisSessionDAO\nredisSessionDAO = org.crazycake.shiro.RedisSessionDAO\n\n# Use redisManager as cache manager\nredisSessionDAO.redisManager = $redisManager\n\nsessionManager = org.apache.shiro.web.session.mgt.DefaultWebSessionManager\n\nsessionManager.sessionDAO = $redisSessionDAO\n\nsecurityManager.sessionManager = $sessionManager\n\n#=========================================\n# Redis session DAO [end]\n#=========================================\n\n#==========================================\n# Redis cache manager [start]\n#==========================================\n\n# Create cacheManager\ncacheManager = org.crazycake.shiro.RedisCacheManager\n\n# Principal id field name. The field which you can get unique id to identify this principal.\n# For example, if you use UserInfo as Principal class, the id field maybe `id`, `userId`, `email`, etc.\n# Remember to add getter to this id field. For example, `getId()`, `getUserId()`, `getEmail()`, etc.\n# Default value is id, that means your principal object must has a method called `getId()`\ncacheManager.principalIdFieldName = id\n\n# Use redisManager as cache manager\ncacheManager.redisManager = $redisManager\n\nsecurityManager.cacheManager = $cacheManager\n\n#==========================================\n# Redis cache manager [end]\n#==========================================\n\n#=================================\n# shiro-redis configuration [end]\n#=================================\n```\n\n有关完整的可配置选项列表，请检查[Configurable Options](http://alexxiyang.github.io/shiro-redis/#configurable-options)。\n\n这是一个[教程项目，](https://github.com/alexxiyang/shiro-redis-tutorial)让您了解如何`shiro-redis`在`shiro.ini`.\n\n### Redis哨兵\n\n如果您使用的是Redis Sentinel，请将`redisManager`独立版本的配置替换为以下内容：\n\n```\n#===================================\n# Redis Manager [start]\n#===================================\n\n# Create redisManager\nredisManager = org.crazycake.shiro.RedisSentinelManager\n\n# Sentinel host. If you don\'t specify host the default value is 127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381\nredisManager.host = 127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381\n\n# Sentinel master name\nredisManager.masterName = mymaster\n\n#===================================\n# Redis Manager [end]\n#===================================\n```\n\n有关完整的可配置选项列表，请检查[Configurable Options](http://alexxiyang.github.io/shiro-redis/#configurable-options)。\n\n### Redis 集群\n\n如果您使用的是redis集群，请将`redisManager`独立版本的配置替换为以下内容：\n\n```\n#===================================\n# Redis Manager [start]\n#===================================\n\n# Create redisManager\nredisManager = org.crazycake.shiro.RedisClusterManager\n\n# Redis host and port list\nredisManager.host = 192.168.21.3:7000,192.168.21.3:7001,192.168.21.3:7002,192.168.21.3:7003,192.168.21.3:7004,192.168.21.3:7005\n\n#===================================\n# Redis Manager [end]\n#===================================\n```\n\n有关完整的可配置选项列表，请检查[Configurable Options](http://alexxiyang.github.io/shiro-redis/#configurable-options)。\n\n## Spring\n\n如果您使用的是 Spring\n\n### Redis 独立\n\n如果您在独立模式下运行 Redis\n\n```\n<!-- shiro-redis configuration [start] -->\n\n<!-- Redis Manager [start] -->\n<bean id=\"redisManager\" class=\"org.crazycake.shiro.RedisManager\">\n    <property name=\"host\" value=\"127.0.0.1:6379\"/>\n</bean>\n<!-- Redis Manager [end] -->\n\n<!-- Redis session DAO [start] -->\n<bean id=\"redisSessionDAO\" class=\"org.crazycake.shiro.RedisSessionDAO\">\n    <property name=\"redisManager\" ref=\"redisManager\" />\n</bean>\n<bean id=\"sessionManager\" class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\">\n    <property name=\"sessionDAO\" ref=\"redisSessionDAO\" />\n</bean>\n<!-- Redis session DAO [end] -->\n\n<!-- Redis cache manager [start] -->\n<bean id=\"cacheManager\" class=\"org.crazycake.shiro.RedisCacheManager\">\n    <property name=\"redisManager\" ref=\"redisManager\" />\n</bean>\n<!-- Redis cache manager [end] -->\n\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"sessionManager\" ref=\"sessionManager\" />\n    <property name=\"cacheManager\" ref=\"cacheManager\" />\n\n    <!-- other configurations -->\n    <property name=\"realm\" ref=\"exampleRealm\"/>\n    <property name=\"rememberMeManager.cipherKey\" value=\"kPH+bIxk5D2deZiIxcaaaA==\" />\n</bean>\n\n<!-- shiro-redis configuration [end] -->\n```\n\n有关完整的可配置选项列表，请检查[Configurable Options](http://alexxiyang.github.io/shiro-redis/#configurable-options)。\n\n这里有一个[教程项目，](https://github.com/alexxiyang/shiro-redis-spring-tutorial)让你了解如何`shiro-redis`在spring配置文件中进行配置。\n\n### Redis哨兵\n\n如果使用redis sentinel，请将`redisManager`单机版的配置改为如下：\n\n```\n<!-- shiro-redis configuration [start] -->\n<!-- shiro redisManager -->\n<bean id=\"redisManager\" class=\"org.crazycake.shiro.RedisSentinelManager\">\n    <property name=\"host\" value=\"127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381\"/>\n    <property name=\"masterName\" value=\"mymaster\"/>\n</bean>\n```\n\n有关完整的可配置选项列表，请检查[Configurable Options](http://alexxiyang.github.io/shiro-redis/#configurable-options)。\n\n### Redis 集群\n\n如果使用redis集群，请将`redisManager`standalone版本的配置改为如下：\n\n```\n<!-- shiro-redis configuration [start] -->\n<!-- shiro redisManager -->\n<bean id=\"redisManager\" class=\"org.crazycake.shiro.RedisClusterManager\">\n    <property name=\"host\" value=\"192.168.21.3:7000,192.168.21.3:7001,192.168.21.3:7002,192.168.21.3:7003,192.168.21.3:7004,192.168.21.3:7005\"/>\n</bean>\n```\n\n有关完整的可配置选项列表，请检查[Configurable Options](http://alexxiyang.github.io/shiro-redis/#configurable-options)。\n\n## 序列化器 Serializer\n\n由于 redis 只接受`byte[]`，就会出现序列化问题。Shiro-redis`StringSerializer`用作键序列化器和`ObjectSerializer`值序列化器。你可以使用你自己的自定义序列化器，只要这个自定义序列化器实现`org.crazycake.shiro.serializer.RedisSerializer`\n\n例如，我们可以像这样更改 keySerializer 的字符集\n\n```\n# If you want change charset of keySerializer or use your own custom serializer, you need to define serializer first\n#\n# cacheManagerKeySerializer = org.crazycake.shiro.serializer.StringSerializer\n\n# Supported encodings refer to https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html\n# UTF-8, UTF-16, UTF-32, ISO-8859-1, GBK, Big5, etc\n#\n# cacheManagerKeySerializer.charset = UTF-8\n\n# cacheManager.keySerializer = $cacheManagerKeySerializer\n```\n\n您可以使用自定义序列化程序替换这 4 个选项：\n\n- cacheManager.keySerializer\n- cacheManager.valueSerializer\n- redisSessionDAO.keySerializer\n- redisSessionDAO.valueSerializer\n\n## 可配置选项 Configurable Options\n\n以下是您可以在`shiro-redis`配置文件中使用的所有可用选项。\n\n### Redis管理器\n\n| **Title**       | **Default**                                 | **Description**                                              |\n| :-------------- | :------------------------------------------ | :----------------------------------------------------------- |\n| host            | `127.0.0.1:6379`                            | Redis 主机。如果您不指定主机，则默认值为`127.0.0.1:6379`. 如果你在哨兵模式或集群模式下运行 redis，用逗号分隔主机名，如`127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381` |\n| masterName      | `mymaster`                                  | **仅用于哨兵模式** Redis哨兵模式的主节点                     |\n| timeout         | `2000`                                      | Redis 连接超时。jedis 尝试连接到 redis 服务器超时（以毫秒为单位） |\n| soTimeout       | `2000`                                      | **仅用于哨兵模式或集群模式** jedis尝试从redis服务器读取数据的超时时间 |\n| maxAttempts     | `3`                                         | **仅用于集群模式** 最大尝试连接到服务器                      |\n| password        |                                             | Redis密码                                                    |\n| database        | `0`                                         | Redis 数据库。默认值为 0                                     |\n| jedisPoolConfig | `new redis.clients.jedis.JedisPoolConfig()` | JedisPoolConfig. 您可以创建自己的 JedisPoolConfig 实例并根据需要设置属性 大多数情况下，您不需要设置 jedisPoolConfig 这里是一个示例。 `jedisPoolConfig = redis.clients.jedis.JedisPoolConfig` `jedisPoolConfig.testWhileIdle = false` `redisManager.jedisPoolConfig = jedisPoolConfig` |\n| count           | `100`                                       | 扫描计数。Shiro-redis 使用 Scan 来获取键，因此您可以定义每次迭代返回的元素数量。 |\n| jedisPool       | `null`                                      | **仅用于哨兵模式或单模式** 您可以创建自己的 JedisPool 实例并根据需要设置属性 |\n\n### RedisSessionDAO\n\n| **Title**              | **Default**                                       | **Description**                                              |\n| :--------------------- | :------------------------------------------------ | :----------------------------------------------------------- |\n| redisManager           |                                                   | 您刚刚在上面配置的RedisManager（必需）                       |\n| expire                 | `-2`                                              | Redis 缓存键/值过期时间。过期时间以秒为单位。 特殊值： `-1`: no expire `-2`：与会话超时相同 默认值：`-2` **注意**：确保过期时间长于会话超时。 |\n| keyPrefix              | `shiro:session:`                                  | 为会话管理自定义您的 redis 密钥前缀 **注意**：请记住在前缀末尾添加冒号。 |\n| sessionInMemoryTimeout | `1000`                                            | 当我们登录时，`doReadSession(sessionId)`会被 shiro 调用大约 10 次。所以shiro-redis将Session保存在ThreadLocal中来缓解这个问题。sessionInMemoryTimeout 是 ThreadLocal 中 Session 的到期时间。 大多数情况下，您不需要更改它。 |\n| sessionInMemoryEnabled | `true`                                            | 是否在 ThreadLocal 中启用临时保存会话                        |\n| keySerializer          | `org.crazycake.shiro.serializer.StringSerializer` | 缓存管理器的key serializer 你可以改变key serializer 的实现或者StringSerializer 的编码。 支持的编码是指[支持的编码](https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html)。如`UTF-8`, `UTF-16`, `UTF-32`, `ISO-8859-1`, `GBK`, `Big5`, 等 更多细节请查看[Serializer](http://alexxiyang.github.io/shiro-redis/#serializer) |\n| valueSerializer        | `org.crazycake.shiro.serializer.ObjectSerializer` | 缓存管理器的值序列化器 您可以更改值序列化器的实现 有关更多详细信息，请查看[Serializer](http://alexxiyang.github.io/shiro-redis/#serializer) |\n\n### CacheManager 缓存管理器\n\n| **Title**            | **Default**                                       | **Description**                                              |\n| :------------------- | :------------------------------------------------ | :----------------------------------------------------------- |\n| redisManager         |                                                   | 您刚刚在上面配置的RedisManager（必需）                       |\n| principalIdFieldName | `id`                                              | 主体 ID 字段名称。您可以获得唯一 ID 来标识此主体的字段。 例如，如果您使用 UserInfo 作为 Principal 类，则 id 字段可能`id`是`userId`、`email`、 等。 请记住将 getter 添加到此 id 字段。例如，`getId()`, `getUserId(`),`getEmail()`等。 默认值是`id`，这意味着您的主体对象必须有一个方法调用`getId()` |\n| expire               | `1800`                                            | Redis 缓存键/值过期时间。 过期时间以秒为单位。               |\n| keyPrefix            | `shiro:cache:`                                    | 自定义您的 redis 键前缀以进行缓存管理 **注意**：请记住在前缀末尾添加冒号。 |\n| keySerializer        | `org.crazycake.shiro.serializer.StringSerializer` | 缓存管理器的key serializer 你可以改变key serializer 的实现或者StringSerializer 的编码。 支持的编码是指[支持的编码](https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html)。如`UTF-8`, `UTF-16`, `UTF-32`, `ISO-8859-1`, `GBK`, `Big5`, 等 更多细节请查看[Serializer](http://alexxiyang.github.io/shiro-redis/#serializer) |\n| valueSerializer      | `org.crazycake.shiro.serializer.ObjectSerializer` | 缓存管理器的值序列化器 您可以更改值序列化器的实现 有关更多详细信息，请查看[Serializer](http://alexxiyang.github.io/shiro-redis/#serializer) |\n\n# 弹簧启动器 Spring boot starter\n\n使用`Spring-Boot`集成是集成`shiro-redis`到基于 Spring 的应用程序的最简单方法。\n\n> 注意：`shiro-redis-spring-boot-starter`版本`3.2.1`基于`shiro-spring-boot-web-starter`版本`1.4.0-RC2`\n\n首先`shiro-redis`在您的应用程序类路径中包含Spring boot starter 依赖项\n\n```\n<dependency>\n    <groupId>org.crazycake</groupId>\n    <artifactId>shiro-redis-spring-boot-starter</artifactId>\n    <version>3.3.1</version>\n</dependency>\n```\n\n下一步取决于您是创建了自己的`SessionManager`还是`SessionsSecurityManager`.\n\n## 如果您还没有创建自己的`SessionManager`或`SessionsSecurityManager`\n\n如果您没有自己的`SessionManager`或`SessionsSecurityManager`在您的配置中，`shiro-redis-spring-boot-starter`将创建`RedisSessionDAO`并`RedisCacheManager`为您。然后将它们注入`SessionManager`并`SessionsSecurityManager`自动注入。所以，你都准备好了。享受吧！\n\n## 如果您已经创建了自己的`SessionManager`或`SessionsSecurityManager`\n\n如果您创建了自己的`SessionManager`或`SessionsSecurityManager`喜欢这样的：\n\n```\n@Bean\npublic SessionsSecurityManager securityManager(List<Realm> realms) {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(realms);\n    \n    // other stuff...\n    \n    return securityManager;\n}\n```\n\n然后注入`redisSessionDAO`和已经`redisCacheManager`创建的`shiro-redis-spring-boot-starter`\n\n```\n@Autowired\nRedisSessionDAO redisSessionDAO;\n\n@Autowired\nRedisCacheManager redisCacheManager;\n```\n\n将它们注入您自己的`SessionManager`和`SessionsSecurityManager`\n\n```\n@Bean\npublic SessionManager sessionManager() {\n    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n\n    // inject redisSessionDAO\n    sessionManager.setSessionDAO(redisSessionDAO);\n    \n    // other stuff...\n    \n    return sessionManager;\n}\n\n@Bean\npublic SessionsSecurityManager securityManager(List<Realm> realms, SessionManager sessionManager) {\n    DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(realms);\n\n    //inject sessionManager\n    securityManager.setSessionManager(sessionManager);\n\n    // inject redisCacheManager\n    securityManager.setCacheManager(redisCacheManager);\n    \n    // other stuff...\n    \n    return securityManager;\n}\n```\n\n有关完整示例，请参阅[shiro-redis-spring-boot-tutorial](https://github.com/alexxiyang/shiro-redis-spring-boot-tutorial)\n\n### 配置属性 Configuration Properties\n\n以下是您可以在 Spring-boot 启动器配置中使用的所有可用选项\n\n| 标题 **Title**                                    | 默认 **Default** | 说明 **Description**                                         |\n| :------------------------------------------------ | :--------------- | :----------------------------------------------------------- |\n| shiro-redis.enabled                               | `true`           | 启用 shiro-redis 的 Spring 模块                              |\n| shiro-redis.redis-manager.deploy-mode             | `standalone`     | Redis 部署模式。选项: `standalone`, `sentinel`, \'集群\'       |\n| shiro-redis.redis-manager.host                    | `127.0.0.1:6379` | Redis 主机。如果您不指定主机，则默认值为`127.0.0.1:6379`. 如果你在哨兵模式或集群模式下运行 redis，用逗号分隔主机名，如`127.0.0.1:26379,127.0.0.1:26380,127.0.0.1:26381` |\n| shiro-redis.redis-manager.master-name             | `mymaster`       | **仅用于哨兵模式** Redis哨兵模式的主节点                     |\n| shiro-redis.redis-manager.timeout                 | `2000`           | Redis 连接超时。jedis 尝试连接到 redis 服务器超时（以毫秒为单位） |\n| shiro-redis.redis-manager.so-timeout              | `2000`           | **仅用于哨兵模式或集群模式** jedis尝试从redis服务器读取数据的超时时间 |\n| shiro-redis.redis-manager.max-attempts            | `3`              | **仅用于集群模式** 最大尝试连接到服务器                      |\n| shiro-redis.redis-manager.password                |                  | Redis密码                                                    |\n| shiro-redis.redis-manager.database                | `0`              | Redis 数据库。默认值为 0                                     |\n| shiro-redis.redis-manager.count                   | `100`            | 扫描计数。Shiro-redis 使用 Scan 来获取键，因此您可以定义每次迭代返回的元素数量。 |\n| shiro-redis.session-dao.expire                    | `-2`             | Redis 缓存键/值过期时间。过期时间以秒为单位。 特殊值： `-1`: no expire `-2`：与会话超时相同 默认值：`-2` **注意**：确保过期时间长于会话超时。 |\n| shiro-redis.session-dao.key-prefix                | `shiro:session:` | 为会话管理自定义您的 redis 密钥前缀 **注意**：请记住在前缀末尾添加冒号。 |\n| shiro-redis.session-dao.session-in-memory-timeout | `1000`           | 当我们登录时，`doReadSession(sessionId)`会被 shiro 调用大约 10 次。所以shiro-redis将Session保存在ThreadLocal中来缓解这个问题。sessionInMemoryTimeout 是 ThreadLocal 中 Session 的到期时间。 大多数情况下，您不需要更改它。 |\n| shiro-redis.session-dao.session-in-memory-enabled | `true`           | 是否在 ThreadLocal 中启用临时保存会话                        |\n| shiro-redis.cache-manager.principal-id-field-name | `id`             | 主体 ID 字段名称。您可以获得唯一 ID 来标识此主体的字段。 例如，如果您使用 UserInfo 作为 Principal 类，则 id 字段可能`id`是`userId`、`email`、 等。 请记住将 getter 添加到此 id 字段。例如，`getId()`, `getUserId(`),`getEmail()`等。 默认值是`id`，这意味着您的主体对象必须有一个方法调用`getId()` |\n| shiro-redis.cache-manager.expire                  | `1800`           | Redis 缓存键/值过期时间。 过期时间以秒为单位。               |\n| shiro-redis.cache-manager.key-prefix              | `shiro:cache:`   | 自定义您的 redis 键前缀以进行缓存管理 **注意**：请记住在前缀末尾添加冒号。 |\n\n## Working with `spring-boot-devtools`\n\n如果您使用`shiro-redis`与`spring-boot-devtools`. 请将此行添加到`resources/META-INF/spring-devtools.properties`（如果没有此文件，则创建它）：\n\n```\nrestart.include.shiro-redis=/shiro-[\\\\w-\\\\.]+jar\n```\n\n# 如果您发现任何错误\n**欢迎留言**\n\n**如果您在学习这篇文章之前对Shiro不了解或者掌握程度较低，建议先阅读博主我这篇文章**\n\n[【Springboot学习】Shiro快速入门及与SpringBoot集成](https://blog.csdn.net/qq_45696377/article/details/119818633)\n\n**如果您觉得学有余力，欢迎继续阅读如下文章**\n\n[【Java全栈】Java全栈学习路线及项目全资料总结【JavaSE+Web基础+大前端进阶+SSM+微服务+Linux+JavaEE】](https://blog.csdn.net/qq_45696377/article/details/110575362)\n\n**可爱的人给一个三连吧**','2021-08-25 10:25:32','0');
insert into `m_blog` (`id`, `user_id`, `title`, `description`, `content`, `created`, `status`) values('16','1','ewr ew ','werew r','werwer ','2021-08-25 22:38:29','0');
